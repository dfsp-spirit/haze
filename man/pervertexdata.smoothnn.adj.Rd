% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smooth_nn.R
\name{pervertexdata.smoothnn.adj}
\alias{pervertexdata.smoothnn.adj}
\title{Smooth per-vertex data using nearest-neighbor smoothing based on mesh adjacency information.}
\usage{
pervertexdata.smoothnn.adj(
  mesh_adj,
  pvdata,
  num_iter,
  method = "C++",
  silent = getOption("haze.silent", default = TRUE)
)
}
\arguments{
\item{mesh_adj}{list of vectors of integers, the adjacency list representation of the mesh. One can use the pre-computed adjacency for some special meshes, see \code{\link{mesh.neigh.pre}}. Data for vertices should include the vertex itself.}

\item{pvdata}{numerical vector of per-vertex-data for the mesh, one value per vertex. Data values of \code{NA} will be ignored, allowing you to mask parts of the data. If you pass an nxm matrix, the n rows will be treated as (independent) overlays that should be smoothed in parallel. To set the number of cores to use for parallel processing, set the 'mc_cores' option like this: \code{options("mc.cores"=22L);} before calling this function.}

\item{num_iter}{positive integer, number of smoothing iterations.}

\item{method}{character string, one of 'C++' or 'R'. The C++ version is much faster (about 50 times faster on our test machine), and there is little reason to ever use the R version in production code, so just ignore this.}
}
\value{
numerical vector, the smoothed data.
}
\description{
Smooth per-vertex data using nearest-neighbor smoothing based on mesh adjacency information.
}
\examples{
\dontrun{
mesh = rgl::tetrahedron3d();
mesh_adj = mesh.adj(mesh, k = 1L);
pvd = rnorm(nrow(mesh$vb), mean = 5.0, sd = 1.0);
pvd_smoothed = pervertexdata.smoothnn.adj(mesh_adj, pvd, num_iter = 30L);
}

}
\seealso{
\code{\link{pervertexdata.smoothnn}} if you have a mesh and still need the connectivity to be computed.
}
